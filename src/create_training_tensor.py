import gzip
import pysam
import params
import argparse

import numpy as np

parser = argparse.ArgumentParser(description="Create training tensor data")
parser.add_argument('--benchmark', metavar='DIR', type=str, 
                    default="/home/yang1031/genomeData/ONT_open_datasets/giab_2023.05/analysis/benchmarking/truthset/modified/HG002_GRCh38_1_22_v4.2.1_benchmark_confident_chr1_snps.vcf.gz",
                    help='benchmark variants for training')
# here find candidates of 50 purity sample
parser.add_argument('--fp_variants', metavar='DIR', type=str,
                    default="/home/yang1031/genomeData/ONT_open_datasets/giab_2023.05/analysis/small_variants_happy/hg002_sup_happy_out/modified/hg002_sup_happy_out_snps_FP.vcf.gz",
                    help='false positive variants that generated by Clair3')
parser.add_argument('--align', metavar='DIR', type=str,
                    default="/home/yang1031/genomeData/ONT_open_datasets/giab_2023.05/analysis/hg002/sup/PAO83395.pass.bam",
                    help='alignment BAM file')
parser.add_argument('--out_tensor', metavar='DIR', type=str,
                    default="/home/yang1031/projects/ont_error_corrector/data/ont_alignment/2023.05/hg002/sup/tensor/all_coverage_positice_chr1_negative_all.tensor",
                    help='the output candidate positions that used for training.')
args = parser.parse_args()

def load_vcf(vcf_file):
    positions = {}
    open_func = gzip.open if vcf_file.endswith('.gz') else open
    with open_func(vcf_file, 'rt') as vcf:
        for line in vcf:
            if not line.startswith("#"):
                parts = line.split('\t')
                ref_base = parts[3]
                alt_base = parts[4]
                positions[(parts[0], int(parts[1]))] = (ref_base, alt_base)
    return positions

def extract_data_from_pysam(bam_file, chromosome, position, window):
    with pysam.AlignmentFile(bam_file, "rb") as bam:
        # Pileup over a region
        pileup_columns = bam.pileup(chromosome, position - window, position + window, stepper='nofilter')
        
        # Initialize empty data structure for pileup data
        # Assuming 30 reads from tumor and 30 from normal, 101 positions, 4 channels
        data = np.zeros((int(params.TENSOR_HEIGHT), 2*window + 1, params.TENSOR_CHANNELS))

        for pileup_column in pileup_columns:
            if abs(pileup_column.pos - position) > window:
                continue
            pileup_idx = pileup_column.pos - position + window  # Index in the data array

            for read_idx, pileup_read in enumerate(pileup_column.pileups):
                if read_idx >= int(params.TENSOR_HEIGHT):
                    break

                if pileup_read.query_position is None:
                    continue  # Skip deletion in read
                
                # Channel 1: Read bases (encoded as integers A=1, C=2, G=3, T=4, others=0)
                base = pileup_read.alignment.query_sequence[pileup_read.query_position]
                base_to_num = {'A': 1, 'C': 2, 'G': 3, 'T': 4}
                data[read_idx, pileup_idx, 0] = base_to_num.get(base, 0)

                # Channel 2: Base quality
                data[read_idx, pileup_idx, 1] = pileup_read.alignment.query_qualities[pileup_read.query_position]

                # Channel 3: Read strand (0 for reverse, 1 for forward)
                data[read_idx, pileup_idx, 2] = 0 if pileup_read.alignment.is_reverse else 1

                # Channel 4: Mapping quality
                data[read_idx, pileup_idx, 3] = pileup_read.alignment.mapping_quality
    print(data.shape)
    return data

def main():
    benchmark_positions = load_vcf(args.benchmark)
    fp_positions = load_vcf(args.fp_variants) 
    
    # output positive tensors
    with open(args.out_tensor, 'w') as out_file:
        for (chromosome, position), (ref_base, alt_base) in benchmark_positions.items():
            label = 0
            benchmark_data = extract_data_from_pysam(args.align, chromosome, position, params.TENSOR_WINDOW_SIZE)
            output_line = f'{chromosome}:{position}\t{ref_base}\t{alt_base}\t{label}\t{benchmark_data.flatten().tolist()}\n'
            out_file.write(output_line)
            out_file.flush()
        
        for (chromosome, position), (ref_base, alt_base) in fp_positions.items():
            label = 1
            benchmark_data = extract_data_from_pysam(args.align, chromosome, position, params.TENSOR_WINDOW_SIZE)
            output_line = f'{chromosome}:{position}\t{ref_base}\t{alt_base}\t{label}\t{benchmark_data.flatten().tolist()}\n'
            out_file.write(output_line)
            out_file.flush()
    
if __name__ == "__main__":
    main()